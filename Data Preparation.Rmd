---
title: "Data Preparation"
author: "DARS"
date: "`r Sys.Date()`"
output: pdf_document:
    number_sections: TRUE
---

```{r setup, message = FALSE}
library(tidyverse)
library(tidytext) 

library(gsheet) # import spreadsheets from google drive
library(tm)
library(hunspell) # Stemmer
```

# Import Data
The datasets we use are saved as spreadsheet on our google drive *DARS*. We use the function `gsheet2tbl` to import them to `R Studio` as tibbles. We use the tibble data format (an evolution of the data frame format) because this is the format of reference of the `tidyverse` on whose tools our analysis is heavily based.

## Setup
Before importing the spreadsheets from the drive, let us create two vectors `list_assessment` and `list_AoD` which respectively list the `19` types of assessment and the `18` aims of the degree (AoD) of the degree which we take into consideration in the analysis. The information comes from a spreadsheet from our google drive *DARS* which we save as `lists`. In addition, we also create two additional vectors `list_assessment_plot` and `list_AoD_plot` which contain a selection of prominent assessment types and AoD that we will consider when ploting the data[^1].
```{r list}
lists_brut <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1239912347')

lists <- list(
  Assessment      = lists_brut$Assessment,
  Assessment_plot = lists_brut$Assessment[lists_brut$`Assessment for Plot` == 1],
  AoD             = lists_brut$Aim[!is.na(lists_brut$Aim)],
  AoD_plot        = lists_brut$Aim[lists_brut$`Aim for Plot`[!is.na(lists_brut$Aim)] == 1]
  )
```

## Course Data
We import three spreadsheets from the drive and transform them into the so-called *tidy format*. The tibble `d_course` contains information at the course-level such as in which cluster and concentration(s) they belong and in which period(s) they are offered, the tibble `d_assessment` indicates which type(s) of assessment each course contains with one row per course-assessment and the tibble `d_ILO` indicates which AoD(s) the intended learning objectives (ILOs) of the courses cover with one row per course-ILO-AoD.

```{r import data from drive}
d_course <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1655700848') %>%
  mutate(`Missing from ILO File` = as.logical(`Missing from ILO File`))
print(d_course)

d_assessment <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1102665750') %>%
  select(- `Comment on Assessment`) %>%
  gather(Assessment, assessment_covered, - Code, factor_key = T) %>%
  mutate(assessment_covered = as.logical(assessment_covered)) %>%
  filter(assessment_covered) %>%
  select(- assessment_covered) %>%
  arrange(Code)
print(d_assessment)

d_ILO <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1896457050') %>%
  select(- c(Comments, Comments_for_Jeroen)) %>%
  gather(AoD, AoD_covered, -c(Code, Objectives), factor_key = T) %>%
  mutate(AoD_covered = as.logical(AoD_covered)) %>%
  rename(ILO = Objectives) %>%
  filter(AoD_covered) %>%
  select(- AoD_covered) %>%
  arrange(Code)
print(d_ILO)
```

## Textual Data

### Course Catalogues
In order to conduct a preliminary topic modeling of course content, we first analyze their description in the course catalogues. The corpus `corpus` contains the pdfs of the `5` most recent course catalogues.
```{r corpus, cache = TRUE}
corpus <- Corpus(x             = DirSource("Catalogues"),
                 readerControl = list(reader = readPDF(control = list(text = "-layout"))))
```

### Course Manuals
To expand our topic modeling of course content, we would like to analyse the material in the course manuals. The `corpus_manuals` contains the pdfs of the course manuals for the year 2017-2018 (most recently, available).
```{r}
corpus_manuals <- Corpus(x             = DirSource("Manuals 2017-18"),
                 readerControl = list(reader = readPDF(control = list(text = "-layout"))))
```
## Student Data
The tibble `transcripts` contains the transcripts of a selection of `7` alumni students from the college[^2]. `transcripts` contains information on each course taken by each student such as the receives grade, the semester in which teh course was taken as well as the calendar year.
```{r transcripts}
transcripts <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1kj7tlfJAoN0F7IdoS3saT-2iC3nuDLwnDItNtCKoZ4k/edit#gid=936718979')
print(transcripts)
```

# Variable Engineering

## AoD
In this analysis, we conside that a course can cover an AoD in two ways: a course covers an AoD if one of its ILOs covers it or if one of its assessments cover it. For instance, if one of the ILO of a course states that the students will learn to analyze empirical data in the context of academic research, then the course in question covers the AoD `Research Skills`; and if one of the assessment is a group presentation, then the course also covers the AoD `Collaborative Skills` and `Communication Skills`.

### AoD from ILOs
In order to determine which AoD each course covers with its ILOs, we first eliminate the AoD that are not covered by the ILOs and then we take the unique combination of course and AoD in case a course had several ILOs covering the same AoD.
```{r}
d_AoD_ILO <- d_ILO %>%
  select(Code, AoD) %>%
  unique

print(d_AoD_ILO)
```

### AoD from Assessment Type
In order to determine which AoD each course covers with its assessments, we need to create a binary matrix which indicates which AoD(s) each assessment type covers. We have created such matrix on our google drive and we save it in the following piece of code as `map_assessment_AoD`. `map_assessment_AoD` indicates that, for instance, the assessment type `Essay` covers the AoD `Critical Thinking Skills`, `Communication Skills` and `Writing Skill`.
```{r}
map_assessment_AoD <- as.matrix(gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=719531216')[,lists$AoD] %>%
                                  mutate_all(as.logical))
rownames(map_assessment_AoD) <- lists$Assessment
print(map_assessment_AoD[1:5, 8:12])
```

Now that we have the matrix `map_assessment_AoD`, we create the tibble `d_assessment_clean` which only contains the assessments that are covered by each course and we loop through its rows to determine which AoD, each assessment covers. In the loop, we first extract the row of `d_assessment_clean` and save it as `observation` and determine the corresponding assessment which we save as `assessment`. Then we use the matrix `map_assessment_AoD` to determine which AoD `assessment` covers and use `cbind` and `rbind` to add the information to the tibble `d_AoD_assessment`.
```{r}
d_AoD_assessment <- tibble(Code        = character(0),
                           Assessment  = character(0),
                           AoD         = character(0))

for(i in 1 : nrow(d_assessment)){
  
  observation <- d_assessment[i, ]
  
  assessment  <- observation$Assessment
  AoD_covered <- map_assessment_AoD[assessment, ]
  AoD         <- lists$AoD[AoD_covered]
  
  if(length(AoD) >= 1){ # if no AoD are covered by assessment (e.g. written exam), then do not rbind rows to d_AoD_assessment
      AoD_assessment_tidy <- cbind(observation, AoD) %>%
    as_tibble
      d_AoD_assessment <- rbind(d_AoD_assessment, AoD_assessment_tidy)
  }

}

print(d_AoD_assessment)
```

Similarly to what we did with the tibble `d_AoD_ILO`, we first eliminate the AoD that are not covered by the assessments and then we take the unique combination of course and AoD in case a course had several assessments covering the same AoD.
```{r}
d_AoD_assessment <- d_AoD_assessment %>%
  select(Code, AoD) %>%
  unique
print(d_AoD_assessment)
```

### Combining AoD from ILOs and from assessments
Finally, we can use a `rbind` to combine the two tibbles `d_AoD_ILO` and `d_AoD_assessment`. We also use `unique` in case a course covers an AoD with both its ILOS and its assessments.
```{r}
d_AoD <- rbind(d_AoD_ILO, d_AoD_assessment) %>%
  unique %>%
  arrange(Code)
print(d_AoD)
```

## Course Data
Now that we have a clear overview of the distribution of AoDs (`d_AoD`) and assessments (`d_assessment`) among the courses, let us add variables to the tibble `d_course` that contain the information at the course level. The tibble `d_ILO_detail` contains two columns indicating the code of the course and the number of ILOs it contains; `d_assessment_detail` contains three columns indicating the code of the course, the number of assessments it covers and a list of the assessments it covers; `d_AoD_detail` contains three columns indicating the code of the course, the number of AoD it covers and a list of the AoD it covers. We use a `full_join` to add these variables to the tibble `d_course`.
```{r}
d_ILO_detail <- d_ILO %>% 
  select(Code, ILO) %>%
  unique %>%
  count(Code) %>%
  rename(n_ILO = n)
print(d_ILO_detail)

d_assessment_detail <- d_assessment %>%
  group_by(Code) %>%
  summarise(n_assessment = n(),
            `Assessments Covered` = paste(Assessment, collapse = ", "))
print(d_assessment_detail)

d_AoD_detail <- d_AoD %>%
  group_by(Code) %>%
  summarise(n_AoD = n(),
            `AoD Covered` = paste(AoD, collapse = ", "))
print(d_AoD_detail)
```

```{r}
d_course <- d_course %>%
  full_join(d_ILO_detail       , by = "Code") %>%
  full_join(d_assessment_detail, by = "Code") %>%
  full_join(d_AoD_detail       , by = "Code") %>%
  select(Code, `Course Title`, Cluster, n_ILO, n_assessment, `Assessments Covered`, n_AoD, `AoD Covered`, everything())
print(d_course)
```

The undegraduate research courses (*UGR-*) are only present at the `3000` level (advanced level). Yet, these course are also offered at the `2000` level (intermediate level). We use an `rbind` to duplicate the rows of the course `UGR3000` and mutate their `Code` to `UGR2000`.
```{r}
d_course <- d_course %>%
  rbind(filter(., Code %in% c("UGR3001", "UGR3002", "UGR3003", "UGR3005")) %>%
          mutate(Code = case_when(Code == "UGR3001" ~ "UGR2001",
                                  Code == "UGR3002" ~ "UGR2002",
                                  Code == "UGR3003" ~ "UGR2003",
                                  Code == "UGR3005" ~ "UGR2005")))

print(filter(d_course, Code %in% c("UGR2001", "UGR2002", "UGR2003", "UGR2005",
                                   "UGR3001", "UGR3002", "UGR3003", "UGR3005")))
```

Finally, we add a series of informative variable at the course level.
```{r}
d_course <- d_course %>%
  mutate(
    `Missing from ILO File` = as.logical(`Missing from ILO File`),
    Letters = substring(Code, 1, 3),
    Number  = as.numeric(substring(Code, 4, 7)),
    Level   = case_when(between(Number, 1000, 1999) ~ "Introductory",
                        between(Number, 2000, 2999) ~ "Intermediate",
                        between(Number, 3000, 3999) ~ "Advanced"    ))
print(select(d_course, Code, Letters, Number, Level))
```

## Course Catalogue
In order to conduct a topic analysis of course content, we extract the *overview* and *description* of each course from the course catalogues.

### Extracting Overviews
We start by extracting the overviews which are 1 or 2 page long and contain important information of a course. To accomplish this, for each catalogue (loop), we first use `grep` to determine which pages should be excluded from the analysis (`pages_to_exclude`). These pages are typically headers. Excluding them before the analysis allows use to keep the code relatively simple. We also make use the fact that the overviews always start with the code of the course, i.e. it starts with one of the elements of `course_code` and use `grep` to identify the first page of each overview. We use grep a 3rd time to identify the page containing the header *Core Coureses (COR)* and which marks the beginning of the overviews in the catalogue, and we loop from this page to the last page of the catalogue.

In the loop, we first determine the content of the current and following page. If the current page is the first page of an overview, then we identify the overview (one or two pages) and save it to the tibble `d_description`. To identify the overview of a course, we check if the following page is either the first page of an overview or a page to exclude. If it is either of these, then the overview correspond to the content of the current page; but if the following page is neiter of these, then the overview correspond to the content of the current page and that of the following page.

```{r overview}
# Setup
n_catalogue <- length(corpus)
calendar_years <- c("2014-2015", "2015-2016", "2016-2017", "2017-2018", "2018-2019")
d_description <- tibble(Code            = character(0),
                        `Calendar Year` = character(0),
                        Overview        = character(0))

course_code <- c("COR", "HUM", "SCI", "SSC", "SKI", "PRO", "UGR", "CAP")
course_code <- paste(course_code, collapse = "|")

content_to_exclude <- c("^Core Courses \\(COR\\)",
                        "^Humanities \\(HUM\\)",
                        "^Sciences \\(SCI\\)",
                        "^Social Sciences \\(SSC\\)",
                        "^Skills Trainings \\(SKI\\)",
                        "^Projects \\(PRO\\)",
                        "^Undergraduate Research \\(UGR\\)",
                        "Appendix")
content_to_exclude <- paste(content_to_exclude, collapse = "|")

# Loop
for(n in 1 : n_catalogue){
  
  cat <- content(corpus[[n]])
  
  pages_to_exclude     <- grep(pattern = content_to_exclude, x = cat)
  first_three_letters  <- substr(cat, start = 1, stop = 3)
  first_pages_overview <- grep(pattern = course_code, x = first_three_letters)
  
  page_start_loop <- grep(pattern = "^Core Courses \\(COR\\)", x = cat) + 1
  page_end_loop   <- length(cat)
  
  for(page in page_start_loop : page_end_loop){
    
    current_page           <- page
    following_page         <- page + 1
    current_page_content   <- cat[page          ]
    following_page_content <- cat[following_page]
    
    if(current_page %in% first_pages_overview){
      
      if(following_page %in% c(first_pages_overview, pages_to_exclude)) course_overview <- current_page_content
      else course_overview <- paste(current_page_content, following_page_content)

      # Save Overview
      Code <- substring(course_overview, first = 1, last = 7)      
      year <- calendar_years[n]
      d_description <- add_row(d_description,
                               Code            = Code,
                               `Calendar Year` = year,
                               Overview        = course_overview)
    } # close if-statement
  } # close for-loop (page)
} # close for-loop (n)

print(d_description)
```

### Extracting Descriptions
Since the overviews contain a lot of information that does not interest us, we extract the description section of the overviews. The description section contains a brief description (200-500 words) of the content of the course. To accomplish this, for each overview, we need to identify the line where the description starts and the line where it ends. The description section is always preceeded by a header saying *Description* or *Course Description* (`start_descrip`), making it relatively easy to find the starting line of the decription section with `grep`. The description section is usually followed by the literature section which starts with header saying *Literature*, *Recommended Literature* or similar (see `end_descrip`). Using `grep` together with `end_descrip`, we can again identify the ending line of the description section of almost overviews. A handful overviews do not contain a *Literature* section. For these, the section *Instructional Format* marks the end of the description section.
```{r description}
# Setup
symbol_to_line <- c("\r\n", "\n")
symbol_to_line <- paste(symbol_to_line, collapse = "|")

start_descrip <- c("^Description", "^Course Description")
start_descrip <- paste(start_descrip, collapse = "|")

end_descrip   <- c("^Literature$", "^Recommended Literature", "^ Required Litera",
                   "^Required Litera", "^ Literature$", "Literature \\(all")
end_descrip   <- paste(end_descrip, collapse = "|")

d_description <- d_description %>%
  mutate(Description = NA)

# Loop
for(course in 1 : nrow(d_description)){
  
  overview <- d_description$Overview[course]
  
  overview_line <- strsplit(x = toString(overview), split = symbol_to_line)[[1]]
  line_start    <- grep(pattern = start_descrip, x = overview_line) + 1
  line_end      <- grep(pattern = end_descrip  , x = overview_line) - 1

  # for overviews w/o Literature section, find section Instructional Format.
  if(is_empty(line_end)){
    line_end <- grep(pattern = "^Instructional format$", x = overview_line) - 1
    print(paste("line_end irregular for", d_description$Code[course],
                "in catalogue", d_description$`Calendar Year`[course]))
    } # close if-statement
  
  description <- paste(overview_line[line_start : line_end], collapse = " ")
  
  d_description$Description[course] <- description
  
}

print(d_description)
```

### Tidy Text Format
We first create two tibbles `d_overview_tidy` and `d_description_tidy` that respectively store the overviews and the descriptions in the tidy text format, with one row per course-year-word.
```{r tidy text data}
d_overview_tidy <- d_description %>%
  select(Code, `Calendar Year`, Overview) %>%
  unnest_tokens(output = word, input = Overview)
print(d_overview_tidy)

d_description_tidy <- d_description %>%
  select(Code, `Calendar Year`, Description) %>%
  unnest_tokens(output = word, input = Description)
print(d_description_tidy)
```

### Stemming
We then use the function `hunspell__stem`, which returns valid stems for a given word, to stem the words in the tibbles `d_overview_tidy` and `d_description_tidy`. We first create a function `stem_hunspell` which, given a term, returns its most basic stem (the last one from the list of stem returned by `hunspell__stem`). We then apply `stem_hunspell` on the words of `d_overview_tidy`. Since, `stem_hunspell` is not a vectorized function and the number of words in `d_overview_tidy` is large, we first use distinct on the `word` variable to find the a list containing *once* each term present in the course overviews and apply the function `stem_hunspell` on this list. We save the terms and their stems in the tibble `stems`. Since the course descriptions can be conceptualized as a subset of the course overviews, the tibble `stems` contains all the terms present in the descriptions and can therefore safely used to stem the words in `d_description_tidy`.
```{r function stem_hunspell, cache = TRUE}
stem_hunspell <- function(term) {
  # look up the term in the dictionary
  stems <- hunspell_stem(term)[[1]]
  
  if (length(stems) == 0) { # if there are no stems, use the original term
    stem <- term
  } else { # if there are multiple stems, use the last one
    stem <- stems[[length(stems)]]
  }
  
  return(stem)
}

stems <- d_overview_tidy %>% 
  select(word) %>%
  distinct %>%
  arrange(word) %>%
  mutate(word_stem = purrr::map_chr(.x = word,
                                    .f = stem_hunspell))

# terms for which the stem differs from the original word
stems %>%
  filter(word != word_stem)
```

```{r stemming}
d_overview_stem <- d_overview_tidy %>%
  left_join(stems, by = "word") %>%
  rename(word_original = word,
         word = word_stem) %>%
  filter(!word %in% stop_words$word)
print(d_overview_stem) # See humanities - humanity

d_description_stem <- d_description_tidy %>%
  left_join(stems, by = "word") %>%
  rename(word_original = word,
         word = word_stem) %>%
  filter(!word %in% stop_words$word)
print(d_description_stem) # See starting - start
```


## Course Manual 
We create a dataframe from the Corpus:
```{r}
manuals_td <- tidy(corpus_manuals)
```

From `manuals_td` we are only interested in the text, and the Code of the course. However, we don't have the code but we have a document id that includes it. Therefore we select only the `text` and `id` columns of the `manuals_td`. Then, we extract the code from the `id` and save it in under `Code`, We aso extract the concentration from the `id` and save it under `Concentration`. Finally, we unnest the dataframe to have only one word per row, and call this `manuals_tokens`, this creates a variable `word` and adds all of the text from the course manuals under this column.

```{r}
manuals_tokens <- manuals_td %>%
  select(id,text) %>%
  mutate(Concentration= substring(id, 1, 3), Code= substring(id,1,7))%>%
  unnest_tokens(word, text)
```



# Save Data

```{r}
save(lists, d_course, d_AoD, d_assessment, d_transcript,
     file = "data_pillar_1.RDATA")
save(lists, d_course, d_AoD, d_assessment, d_transcript,
     d_overview_stem, d_description_stem,
     file = "data_pillar_2.RDATA")
```

[^1]: We do not include all assessments and all AoDs on the plots in order to keep them readable.

[^2]: We are currently cleaning the dataset containing the transcripts of all the students of the college (alumni and current students) in order to integrate it to the analysis.