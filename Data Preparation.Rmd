---
title: "Data Preparation"
author: "DARS"
date: "`r Sys.Date()`"
output: 
  github_document:
    toc: TRUE
---

```{r libraries, message = FALSE}
library(tidyverse)
library(tidytext) 

library(gsheet) # import spreadsheets from google drive
library(tm)
library(hunspell) # Stemmer
#library(rlist)
```

# Import Data
The datasets we use are saved as spreadsheet on our google drive *DARS* (with exeption of grade data saved as csv files on the computer for privacy reasons). We use the function `gsheet2tbl` to import them to `R Studio` as tibbles. We use the tibble data format (an evolution of the data frame format) because this is the format of reference of the `tidyverse` on whose tools our analysis is heavily based.

## Setup
Before importing the spreadsheets from the drive, let us create two vectors `list_assessment` and `list_AoD` which respectively list the `19` types of assessment and the `18` aims of the degree (AoD) of the degree which we take into consideration in the analysis. The information comes from a spreadsheet from our google drive *DARS* which we save as `lists`. In addition, we also create two additional vectors `list_assessment_plot` and `list_AoD_plot` which contain a selection of prominent assessment types and AoD that we will consider when ploting the data[^1].
```{r import list}
lists_brut <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1239912347')

lists <- list(
  Assessment      = lists_brut$Assessment,
  Assessment_plot = lists_brut$Assessment[lists_brut$`Assessment for Plot` == 1],
  AoD             = lists_brut$Aim[!is.na(lists_brut$Aim)],
  AoD_plot        = lists_brut$Aim[lists_brut$`Aim for Plot`[!is.na(lists_brut$Aim)] == 1]
  )

rm(lists_brut)
```

## Course Data
We import three spreadsheets from the drive and transform them into the so-called *tidy format*. The tibble `d_course` contains information at the course-level such as in which cluster and concentration(s) they belong, and in which period(s) they are offered. The tibble `d_assessment` indicates which type(s) of assessment each course contains with one row per course-assessment; and the tibble `d_ILO` indicates which AoD(s) the intended learning objectives (ILOs) of the courses cover with one row per course-ILO-AoD.

```{r import d_course d_assessment and d_ILO, cache = TRUE}
d_course <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1655700848') %>%
  mutate(`Missing from ILO File` = as.logical(`Missing from ILO File`))
print(d_course)

d_assessment <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1102665750') %>%
  select(- `Comment on Assessment`) %>%
  gather(Assessment, assessment_covered, - Code, factor_key = T) %>%
  mutate(assessment_covered = as.logical(assessment_covered)) %>%
  filter(assessment_covered) %>%
  select(- assessment_covered) %>%
  arrange(Code)
print(d_assessment)

d_ILO <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=1896457050') %>%
  select(- c(Comments, Comments_for_Jeroen)) %>%
  gather(AoD, AoD_covered, -c(Code, Objectives), factor_key = T) %>%
  mutate(AoD_covered = as.logical(AoD_covered)) %>%
  rename(ILO = Objectives) %>%
  filter(AoD_covered) %>%
  select(- AoD_covered) %>%
  arrange(Code)
print(d_ILO)
```

## Textual Data

### Course Catalogues
In order to conduct a preliminary topic modeling of course content, we first analyze their description in the course catalogues. The corpus `corpus_catalogues` contains the pdfs of the `5` most recent course catalogues.
```{r import corpus_catalogues, cache = TRUE}
corpus_catalogues <- Corpus(x             = DirSource("Catalogues"),
                            readerControl = list(reader = readPDF(control = list(text = "-layout"))))
```

### Course Manuals
To expand our topic modeling of course content, we analyse the material in the course manuals. The `corpus_manuals` contains the pdfs of the course manuals for the year 2017-2018 (most recently, available).

```{r import corpus_manuals, cache = TRUE}
corpus_manuals <- Corpus(x             = DirSource("Manuals 2017-18"),
                         readerControl = list(reader = readPDF(control = list(text = "-layout"))))
```
## Student Data
The tibble `d_transcript` contains the transcript information of students as was provided. It has 40 columns, and rows correspond to a type of grade (e.g. final grade, attendance) per student per course per time they took it.

```{r import d_transcript, cache = TRUE}
d_transcript <- rbind(read_csv("Raw Grades/grades1.csv", col_types = cols()),
                      read_csv("Raw Grades/grades2.csv", col_types = cols())) %>%
  distinct
```

# Variable Engineering
##Course Data
### AoD
In this analysis, we conside that a course can cover an AoD in two ways: a course covers an AoD if one of its ILOs covers it, or if one of its assessments cover it. For instance, if one of ILO of a course states that the students will learn to analyze empirical data in the context of academic research, then the course in question covers the AoD `Research Skills`; and if one of the assessment is a group presentation, then the course also covers the AoD `Collaborative Skills` and `Communication Skills`.

#### AoD from ILOs
(For this section we use: `d_ILO`-indicates which AoD(s) the intended learning objectives (ILOs) of the courses cover with one row per course-ILO-AoD)

In order to determine which AoD each course covers with its ILOs, we first eliminate the AoD that are not covered by the ILOs, and then we keep only one instance of each combination of course and AoD in case a course had several ILOs covering the same AoD.
```{r d_AoD_ILO}
d_AoD_ILO <- d_ILO %>%
  select(Code, AoD) %>%
  unique

print(d_AoD_ILO)
```

#### AoD from Assessment
(For this section we use: `d_assessment`-indicates which type(s) of assessment each course contains with one row per course-assessment)

In order to determine which AoD each course covers with its assessments, we need to create a binary matrix which indicates which AoD(s) each assessment type covers. We have created such matrix on our google drive and we save it in the following piece of code as `map_assessment_AoD`. `map_assessment_AoD` indicates that, for instance, the assessment type `Essay` covers the AoD `Critical Thinking Skills`, `Communication Skills` and `Writing Skill`.

```{r map_assessment_AoD}
map_assessment_AoD <- as.matrix(gsheet2tbl('https://docs.google.com/spreadsheets/d/1soRA1u5zf9oLNirGmZ9yZ7m2ccPa3XFemnxkj5AVRXo/edit#gid=719531216')[,lists$AoD] %>%
                                  mutate_all(as.logical))
rownames(map_assessment_AoD) <- lists$Assessment
print(map_assessment_AoD[1:5, 8:12])
```

Now that we have the matrix `map_assessment_AoD`, we want to find out which AoDs are covered by a course through its assessments. To do this we create an empty tibble `d_AoD_assessment` to store which assessment is covered by each course, and which AoD said assessment covers.Then, we fill in the information with a loop.
In the loop, we first extract a row of `d_assessment` and save it as `observation`. Then, we determine the corresponding assessment which we save as `assessment`. Then, we use the matrix `map_assessment_AoD` to determine which AoD `assessment` covers and use `cbind` and `rbind` to add the information to the tibble `d_AoD_assessment`.
```{r d_AoD_assessment}
d_AoD_assessment <- tibble(Code        = character(0),
                           Assessment  = character(0),
                           AoD         = character(0))

for(i in 1 : nrow(d_assessment)){
  
  observation <- d_assessment[i, ]
  
  assessments <- observation$Assessment
  AoD_covered <- map_assessment_AoD[assessments, ]
  AoD         <- lists$AoD[AoD_covered]
  
  if(length(AoD) >= 1) d_AoD_assessment <- rbind(d_AoD_assessment,
                                                 as.tibble(cbind(observation,
                                                                 AoD)))

}

rm(map_assessment_AoD, observation, AoD, AoD_covered, assessments, i)
```

Similarly to what we did with the tibble `d_AoD_ILO`, we first eliminate the AoD that are not covered by the assessments and then we take the unique combination of course and AoD in case a course had several assessments covering the same AoD.
```{r d_AoD_assessment distinct}
d_AoD_assessment <- d_AoD_assessment %>%
  select(Code, AoD) %>%
  distinct
print(d_AoD_assessment)
```

#### Combining AoD from ILOs and from assessments
Finally, we can use a `rbind` to combine the two tibbles `d_AoD_ILO` and `d_AoD_assessment`. We also use `unique` in case a course covers an AoD with both its ILOS and its assessments.
```{r rbind d_AoD_ILO and d_AoD_assessment}
d_AoD <- rbind(d_AoD_ILO,
               d_AoD_assessment) %>%
  distinct %>%
  arrange(Code)

rm(d_AoD_ILO, d_AoD_assessment)
print(d_AoD)
```

### Courses
(In this section we use: `d_course`- contains information at the course-level such as in which cluster and concentration(s) they belong, and in which period(s) they are offered.)

Now that we have a clear overview of the distribution of AoDs (`d_AoD`) and assessments (`d_assessment`) among the courses, let us add variables to the tibble `d_course` that contain the information at the course level. For this we create the following three tibbles:
1) `d_ILO_detail` contains two columns indicating the code of the course and the number of ILOs it contains.
2) `d_assessment_detail` contains three columns indicating the code of the course, the number of assessments it covers and a list of the assessments it covers. 
3) `d_AoD_detail` contains three columns indicating the code of the course, the number of AoD it covers and a list of the AoD it covers. 
Then we use a `full_join` to add these variables to the tibble `d_course`.
```{r d_course detail}
d_ILO_detail <- d_ILO %>% 
  select(Code, ILO) %>%
  distinct() %>%
  count(Code) %>%
  rename(n_ILO = n)

d_assessment_detail <- d_assessment %>%
  group_by(Code) %>%
  summarise(n_assessment = n(),
            `Assessments Covered` = paste(Assessment, collapse = ", "))

d_AoD_detail <- d_AoD %>%
  group_by(Code) %>%
  summarise(n_AoD = n(),
            `AoD Covered` = paste(AoD, collapse = ", "))

d_course_detail <- d_ILO_detail %>%
  full_join(d_assessment_detail, by = "Code") %>%
  full_join(d_AoD_detail       , by = "Code")

rm(d_ILO_detail, d_assessment_detail, d_AoD_detail)
print(d_course_detail)
```

```{r join d_course_detail}
d_course <- full_join(d_course, d_course_detail, by = "Code") %>%
  select(Code, `Course Title`, Cluster, n_ILO, n_assessment, `Assessments Covered`, n_AoD, `AoD Covered`, everything())

rm(d_course_detail)
print(d_course)
```

The undegraduate research courses (*UGR-*) are only present at the `3000` level (advanced level). Yet, these course are also offered at the `2000` level (intermediate level). We use an `rbind` to duplicate the rows of the course `UGR3000` and mutate their `Code` to `UGR2000`.
```{r create UGR2000}
d_course <- d_course %>%
  rbind(filter(., Code %in% c("UGR3001", "UGR3002", "UGR3003", "UGR3005")) %>%
          mutate(Code = case_when(Code == "UGR3001" ~ "UGR2001",
                                  Code == "UGR3002" ~ "UGR2002",
                                  Code == "UGR3003" ~ "UGR2003",
                                  Code == "UGR3005" ~ "UGR2005")))

print(filter(d_course, Code %in% c("UGR2001", "UGR2002", "UGR2003", "UGR2005",
                                   "UGR3001", "UGR3002", "UGR3003", "UGR3005")))
```

Finally, we add a series of informative variable at the course level.
```{r d_course additional info}
d_course <- d_course %>%
  mutate(
    `Missing from ILO File` = as.logical(`Missing from ILO File`),
    Letters = substring(Code, 1, 3),
    Number  = as.numeric(substring(Code, 4, 7)),
    Level   = case_when(between(Number, 1000, 1999) ~ "Introductory",
                        between(Number, 2000, 2999) ~ "Intermediate",
                        between(Number, 3000, 3999) ~ "Advanced"    ))
print(select(d_course, Code, Letters, Number, Level))
```

##Textual Data

### Extracting Text
In order to conduct a topic analysis of course content, we extract the *overview* and *description* of each course from the course catalogues, as well as the  *full text*  from the Course Manuals.

####Course Catalogues
(For this section we use:`corpus_catalogues` contains the pdfs of the `5` most recent course catalogues.)

##### Extracting Overviews

We start by extracting the overviews which are 1 or 2 page long and contain important information of a course. To accomplish this, for each catalogue (loop), we first use `grep` to determine which pages should be excluded from the analysis (`pages_to_exclude`). These pages are typically headers. Excluding them before the analysis allows use to keep the code relatively simple. We also make use the fact that the overviews always start with the code of the course, i.e. it starts with one of the elements of `course_code`; and we use `grep` to identify the first page of each overview. We use grep a 3rd time to identify the page containing the header *Core Coureses (COR)* and which marks the beginning of the overviews in the catalogue, and we loop from this page to the last page of the catalogue.

In the loop, we first determine the content of the current and following page. If the current page is the first page of an overview, then we identify the overview (one or two pages) and save it to the tibble `d_description`. To identify the overview of a course, we check if the following page is either the first page of an overview or a page to exclude. If it is either of these, then the overview correspond to the content of the current page; but if the following page is neiter of these, then the overview correspond to the content of the current page and that of the following page.

```{r extracting overview}
# Setup
n_catalogue <- length(corpus_catalogues)
calendar_years <- c("2014-2015", "2015-2016", "2016-2017", "2017-2018", "2018-2019")
d_description <- tibble(Code            = character(0),
                        `Calendar Year` = character(0),
                        Overview        = character(0))

course_code <- c("COR", "HUM", "SCI", "SSC", "SKI", "PRO", "UGR", "CAP") %>%
  paste(collapse = "|")

content_to_exclude <- c("^Core Courses \\(COR\\)",
                        "^Humanities \\(HUM\\)",
                        "^Sciences \\(SCI\\)",
                        "^Social Sciences \\(SSC\\)",
                        "^Skills Trainings \\(SKI\\)",
                        "^Projects \\(PRO\\)",
                        "^Undergraduate Research \\(UGR\\)",
                        "Appendix") %>%
  paste(collapse = "|")

# Loop
for(n in 1 : n_catalogue){
  
  cat <- content(corpus_catalogues[[n]])
  
  pages_to_exclude     <- grep(pattern = content_to_exclude, x = cat)
  first_three_letters  <- substr(cat, start = 1, stop = 3)
  first_pages_overview <- grep(pattern = course_code, x = first_three_letters)
  
  page_start_loop <- grep(pattern = "^Core Courses \\(COR\\)", x = cat) + 1
  page_end_loop   <- length(cat)
  
  for(page in page_start_loop : page_end_loop){
    
    current_page           <- page
    following_page         <- page + 1
    current_page_content   <- cat[page          ]
    following_page_content <- cat[following_page]
    
    if(current_page %in% first_pages_overview){
      
      if(following_page %in% c(first_pages_overview, pages_to_exclude)) course_overview <- current_page_content
      else course_overview <- paste(current_page_content, following_page_content)

      # Save Overview
      Code <- substring(course_overview, first = 1, last = 7)      
      year <- calendar_years[n]
      d_description <- add_row(d_description,
                               Code            = Code,
                               `Calendar Year` = year,
                               Overview        = course_overview)
    } # close if-statement
  } # close for-loop (page)
} # close for-loop (n)

rm(corpus_catalogues,
   n_catalogue, calendar_years, course_code, content_to_exclude,
   n, cat, pages_to_exclude, first_three_letters, first_pages_overview, page_start_loop, page_end_loop,
   page, current_page, following_page, current_page_content, following_page_content,
   course_overview, Code, year)
print(d_description)
```


##### Extracting Descriptions

Since the overviews contain a lot of information that does not interest us, we extract the description section from the overviews. The description section contains a brief description (200-500 words) of the content of the course. To accomplish this, for each overview, we need to identify the line where the description starts and the line where it ends. The description section is always preceeded by a header saying *Description* or *Course Description* (`start_descrip`), making it relatively easy to find the starting line of the decription section with `grep`. The description section is usually followed by the literature section which starts with header saying *Literature*, *Recommended Literature* or similar (see `end_descrip`). Using `grep` together with `end_descrip`, we can again identify the ending line of the description section of almost all overviews. A handful overviews do not contain a *Literature* section. For these, the section *Instructional Format* marks the end of the description section.

```{r extracting description}
# Setup
symbol_to_line <- c("\r\n", "\n") %>%
  paste(collapse = "|")

start_descrip <- c("^Description", "^Course Description") %>%
  paste(collapse = "|")

end_descrip   <- c("^Literature$", "^Recommended Literature", "^ Required Litera",
                   "^Required Litera", "^ Literature$", "Literature \\(all") %>%
  paste(collapse = "|")

d_description <- d_description %>%
  mutate(Description = NA)

# Loop
for(course in 1 : nrow(d_description)){
  
  overview <- d_description$Overview[course]
  
  overview_by_line <- strsplit(x = toString(overview), split = symbol_to_line)[[1]]
  line_start    <- grep(pattern = start_descrip, x = overview_by_line) + 1
  line_end      <- grep(pattern = end_descrip  , x = overview_by_line) - 1

  # for overviews w/o Literature section, find section Instructional Format.
  if(is_empty(line_end)){
    line_end <- grep(pattern = "^Instructional format$", x = overview_by_line) - 1
    print(paste("line_end irregular for", d_description$Code[course],
                "in catalogue", d_description$`Calendar Year`[course]))
    } # close if-statement
  
  description <- paste(overview_by_line[line_start : line_end], collapse = " ")
  
  d_description$Description[course] <- description
  
}

rm(symbol_to_line, start_descrip, end_descrip,
   course, overview, overview_by_line, line_start, line_end, description)
print(d_description)
```

#### Course Manuals
#####Extracting Full Text
(For this section we use:`corpus_manuals`-contains the pdfs of the course manuals for the year 2017-2018 (most recently, available))

Since we want to use tools from dplyr and tidytext we must first transform our corpus into a dataframe.
```{r d_manual}
d_manual <- tidy(corpus_manuals) %>%
  select(id, text) %>%
  mutate(Code = substring(id, 1, 7)) %>%
  select(-id) %>%
  rename(Manual = text)

rm(corpus_manuals)
print(d_manual)
```

Separately, we want to add the manual textual information to`d_course`which contains information at the course-level such as in which cluster and concentration(s) they belong, and in which period(s) they are offered.
```{r join manuals to d_course}
d_course <- full_join(d_course, d_manual, by = "Code")
```

### Tidy Text Format

To put everything into tidy text format, we first create three tibbles `d_overview_tidy`, `d_description_tidy`, `d_manual` that respectively store the overviews, descriptions and text from manuals in the tidy text format, with one row per course-year-word (and course-word for `d_manual`).
```{r tidy d_description}
d_overview <- d_description %>%
  select(Code, `Calendar Year`, Overview) %>%
  unnest_tokens(output = word, input = Overview)
print(d_overview_tidy)

d_description <- d_description %>%
  select(Code, `Calendar Year`, Description) %>%
  unnest_tokens(output = word, input = Description)

d_manual <- unnest_tokens(d_manual, output = word, input = Manual)
```

### Stemming
We then use the function `hunspell__stem`, which returns valid stems for a given word, to stem the words in the tibbles `d_overview_tidy` and `d_description_tidy`. We first create a function `stem_hunspell` which, given a term, returns its most basic stem (the last one from the list of stem returned by `hunspell__stem`). We then apply `stem_hunspell` on the words of `d_overview_tidy`. Since, `stem_hunspell` is not a vectorized function and the number of words in `d_overview_tidy` is large, we first use distinct on the `word` variable to find a list containing *once* each term present in the course overviews. Then, we apply the function `stem_hunspell` on this list. We save the terms and their stems in the tibble `stems`. Since the course descriptions can be conceptualized as a subset of the course overviews, the tibble `stems` contains all the terms present in the descriptions and can therefore safely used to stem the words in `d_description_tidy`.
```{r stemming dictionary, cache = TRUE}
stem_hunspell <- function(term) {
  stems   <- hunspell_stem(term)[[1]] # look up the term in the dictionary
  n_stems <- length(stems)            # number of stems
  if (n_stems == 0) term              # if no stems, return original term
  else              stems[[n_stems]]  # if multiple stems, return last (most basic) stem
}

dictionary <- select(d_overview, Code, word) %>%
  rbind(d_manual) %>% 
  select(word) %>%
  distinct %>%
  mutate(word_stem = purrr::map_chr(.x = word,
                                    .f = stem_hunspell))

# terms for which the stem differs from the original word
filter(dictionary, word != word_stem)


my_sw <- c("______________________________________________________________________________")

data("stop_words")  #imports common stopwords

my_stop_words <- data.frame (word = c(1:11, "students", )) #no stemming ("students")

manuals_tokens_preprocessed <- manuals_tokens %>%
  anti_join(stop_words)     %>%
  anti_join(my_stop_words) %>%
  anti_join(number_stopwords, by = c("word"="word"))

```

```{r stemming d_description}
d_overview <- d_overview %>%
  left_join(dictionary, by = "word") %>%
  rename(word_original = word,
         word = word_stem) %>%
  filter(!word %in% stop_words$word)

d_description <- d_description %>%
  left_join(dictionary, by = "word") %>%
  rename(word_original = word,
         word = word_stem) %>%
  filter(!word %in% stop_words$word)

rm(stems, stem_hunspell)
print(d_overview_stem) # See humanities - humanity
```
### Removing Stopwords


##Student Data
(In this section we use: `d_transcript`- contains the transcript information of students as was provided. It has 40 columns, and rows correspond roughly to a type of grade (e.g. final grade, attendance) per student per course per time they took it).

###Renaming Variables
First we rename the variable names to make them more comprehensible:
```{r}
d_rename <-d_dirt %>%
  rename(
    ID                     =  "X...Student.Number", 
    Code                   =  "Module..Abbrev..", 
    `Course Title`         =  "Module..Desc..",
    `Program Abbreviation` =  "Program..Abbreviation.", 
    `Program Description`  =  "Program..Description.",               
    Year                   =  "Academic.Year",                      
    Session                =  "Academic.Session",
    `Appraisal Code`       =  "Appraisal.Type",                     
    `Appraisal Title`      =  "Appraisal..Description.",             
    Attempt                =  "Number.rep..attemp",                 
    Grade                  =  "Grade.symbol",                        
    `Appraisal Status`     =  "Appraisal.Status",                   
    `Appraisal Status Description` =  "Appraisal.Status..Desc..",    #is only NA: unique(d4$Appraisal.Status..Desc..)       
    `Booking Reason`       =  "Module.Booking.Reason..Description.",
    `Appraisal Date`       =  "Appraisal.date",                      
    `Attempted Credits`    =  "Attempted.credits",                  
    `Earned Credit`        =  "Earned.Credits",                      
    `Credit Type`          =  "Credit.Type",                        
    `Personnel Number`     =  "Personnel.Number",                  
    `Name (Employee/Applicant)`=  "Name.of.employee.or.applicant",      
    `Individual Work`      =  "Individual.Work",                     
    `Academic Work ID`     =  "Academic.Work.ID",                   
    `Booking Status`       =  "Booking.Status",                      #empty
    `Booking Status Description` =  "Booking.Status..Desc..",             
    `Event Object Id`      =  "Event.Object.Id",                     #empty forwards and including      
    `Business Event Abbreviation` =  "Business.event.abbr.",               
    `Event Description`    =  "Event.Description",                   
    `Start time`           =  "Start.time",                         
    `End time`             =  "End.time",                            
    `Date`                 =  "Date",                               
    `Studyplan`            =  "Studyplan",                           
    `Conditional booking`  =  "Conditiona.booking",                 
    `Wachtlist`            =  "Wachtlist",                           
    `Object ID`            =  "Object.ID",                          
    `Object Name`          =  "Object.name",                         
    `Start Date`           =  "Start.date",                         
    `End Date`             =  "End.Date",                            
    `Number of Weeks`      =  "Number.of.weeks",                      #until this one next has values              
    `Appraiser ID`         =  "Appraiser.ID",                        
    `Appraiser Name`       =  "Appraiser.Name"
    
  ) 
```

###Identifying usless variables
Our dataframe contains many variables that are either empty or meaningless for our analysis. We identify this variables and save them to a vector to remove at a later stage.


NOTE TO RAPHAEL: This was in case we later wanted to use any of the non-empty variables, but I don't think we need this anymore, so you can safely just cut this section and select fewer variables later. 
```{r}
not_keep <- c("Booking Status",
              "Appraisal Status Description",
              "Credit Type",
              "Personnel Number",
              "Event Object Id",     
              "Business Event Abbreviation",               
              "Event Description",                   
              "Start time",                         
              "End time",                            
              "Date",                               
              "Studyplan",                           
              "Conditional booking",                 
              "Wachtlist",                           
              "Object ID", #? has values e.g. 50236380                        
              "Object Name",  #?  has values, e.g. "BE-Universitair Ziekenhuis Brussel"
              "Start Date",   #? has values, e.g.  "12/16/13"                     
              "End Date",     #? has values, e.g. "5/14/10"                      
              "Number of Weeks", 
              "Name (Employee/Applicant)",
              "Appraiser ID",      #HAS VALUES BUT NOT IMPORTANT, e.g. 70011933
              "Appraiser Name",    #HAS VALUES BUT NOT IMPORTANT, e.g.  J.J. Briede  
              "Academic Work ID",  #has values, eg.53EA405080711826E10000008978030A
              "Attempted Credits", #HAS VALUES BUT NOT IMPORTANT
              "Earned Credit",
              "Individual Work",
              "Appraisal Status",
              "Booking Reason",
              "Appraisal Date" #day when grades were put in
              ) 
```

Each faculty had a different code for their calendars, we want to standardise them so we can compare. We convert everything into UCM calendar codes and save it under a variable `Period`:
```{r}
d_rename <-d_rename %>%
  mutate(Period= case_when(
    (Session==100)~"1",
    (Session==101)~"1",
    (Session==102)~"1",
    #(Session==190)~"1", #is not there
    (Session==191)~"1",
    (Session==200)~"2",
    (Session==201)~"2",
    (Session==202)~"2",
    (Session==291)~"2",
    (Session==300)~"3",
    (Session==330)~"3",
    (Session==350)~"3",
    (Session==400)~"4",
    (Session==410)~"4",
    (Session==420)~"4",
    (Session==430)~"4",
    (Session==450)~"4",
    (Session==460)~"4",
    (Session==481)~"4",
    (Session==482)~"4",
    (Session==500)~"5",
    (Session==520)~"5",
    (Session==530)~"5",
    (Session==550)~"5",
    (Session==551)~"5",
    (Session==560)~"5",
    (Session==552)~"5",
    (Session==580)~"5",
    (Session==600)~"6",
    (Session==610)~"6",
    (Session==620)~"6",
    (Session==630)~"6",
    (Session==650)~"6",
    (Session==660)~"6",
    (Session==680)~"5",#WHHHHHHHHHHHHHHHHHAAAAAAAAAAATTTTTTTTTTT?????? Why is this period 5
    (Session==1)~"1,2,3,4,5,6",
    (Session==2)~"1,2,3",
    (Session==3)~"4,5,6",
    #(Session==203)~c("2","3"),#is not there
    (Session==350)~"3,4,5",
    (Session==403)~"4,5",
    (Session==900)~"1,2,3,4,5,6",
    (Session==910)~"1", #ASK ABOUT THE 900'S
    (Session==911)~"1",
    (Session==912)~"1",
    (Session==913)~"1",
    (Session==914)~"1",
    (Session==915)~"1",
    (Session==916)~"1",
    (Session==920)~"1",
    (Session==923)~"1",
    (Session==930)~"1",
    (Session==940)~"1",
    (Session==950)~"1",
    (Session==960)~"1"
     )
           )
```
###Dropping useless variables:
Now that our `Period` variable is clean, we can exclude the variables that we will not use, and we will delete newly generated duplicate rows:

```{r}
d_reduce <- d_rename %>%
  select(-not_keep,-Session,-`Program Abbreviation`)
  
d_reduce <- d_reduce[!duplicated(d_reduce),]
```
###Extracting grades
We notice that there are several values under `Grade` for the same course. We are interested in keeping only the final grades, corresponding to the rows where `Appraisal Title` is marked as "Grade supervisor". 
So lets extract the grades and add the course concentration by keeping the first three letters of the `Code`:

```{r}
d_grade <- d_reduce %>%
  filter(`Appraisal Title` == "Grade supervisor") %>%
  mutate(`Course concentration` = substr(Code, start = 1, stop = 3))

d_grade <- d_grade[!duplicated(d_grade),]
```

##Estimating concentrations:
For our analysis we would also like to know what the concentration of each student is. However, this is not given, so we will have to estimate. We know that the maximimum amount of courses a student can take outside of their concentration is 2. Therefore, if any student has more than two courses in one concetration, this should count towards the concentration. We expect students who addhere strictly to single concentrations, and then students who have a mixed concentration. However, it is possible that a person has not yet taken sufficient courses to make a call on their concentration, we will mark these people as "Undecided". Furthermore, it is possible that a student has taken too many courses out of all the concentrations, we will label these "Confused" and for all other cases we need to check the specifics, therefore we will label them "oops" 


NOTE TO RAPHAEL: we might want o have your course concentrations because they take double concentrations into account!

```{r}
d_student_concentration <- d_grade %>%
  group_by(ID, `Course concentration`) %>%
  summarise(count = n()) %>%
  arrange(ID,desc(count)) %>% #LONG
  spread(`Course concentration`,count, fill=0) %>% #WIDE
  transmute(student_Concentration = case_when(
    (HUM  >  2    &   SSC >  2   &  SCI <= 2) ~ "HUM/SSC",
    (HUM  >  2    &   SSC <= 2   &  SCI >  2) ~ "HUM/SCI",
    (HUM  >  2    &   SSC <= 2   &  SCI <= 2) ~ "HUM",
    (HUM  <= 2    &   SSC >  2   &  SCI >  2)  ~ "SSC/SCI",
    (HUM  <= 2    &   SSC >  2   &  SCI <= 2) ~ "SSC",
    (HUM  <= 2    &   SSC <= 2   &  SCI >  2)  ~ "SCI",
    (HUM  <  2    &   SSC <  2   &  SCI <  2) ~ "UNDECIDED",
    (HUM  >  2    &   SSC >  2   &  SCI >  2) ~ "CONFUSED", #normal cases ^
    (HUM > SCI    &   HUM > SSC)              ~ "HUM",
    (SSC > SCI    &   SSC > HUM)              ~ "SSC",
    (SCI > HUM    &   SCI > SSC)              ~ "HUM",
    TRUE ~ "oops"
  ))
```

Since we will need to check each student with an "oops" concentration to see what happened, lets separate this data for later:
```{r}
checkup <- filter(d_student_concentration, student_Concentration == "oops") 
```

###Getting UCM_YEAR
In order to compare the trajectories of students, we would like to know if the courses were taken in their first, second, third, or whatever year. However, we only have the calendar years. Lets find out to what year of study each calendar year corresponds per student.

First, lets find out, which year was a student's first year and which year was a student's last year (we will also create a variable `Subs_year` that we will substract later to transform from Calendar Year to UCM Year, and a second variable `LengthUCM` that shows us how many years each student stayed at the college):
```{r}

d_year <- d_grade %>%
  select(ID, Code, Year, Period, Grade,`Booking Status Description`, `Course concentration`) %>%
  group_by(ID) %>%
  summarise(FirstYear=min(Year), LastYear=max(Year)) %>%
  mutate(LengthUCM = LastYear-FirstYear, Subs_year=FirstYear-1)
```

Now, lets make a dataframe of students against years, where the year appears in the corresponding cell if a student was in the college at that time:

```{r}

d_year1 <- d_grade %>%
  select(ID, Code, Year, Period, Grade, `Booking Status Description`, `Course concentration`) %>%  
  group_by( ID, Year) %>%
  summarise(Count = n())%>%
  mutate(Present = case_when(Count > 0 ~ Year))%>%
  select(-Count) %>%
  spread(Year,Present, fill = 0)

```

Now we have collected all the years a student has been at the college in a single row (one row per student), and we also know what is the first and last year of each student. Let's join these dataframes:

```{r}

d_time <- left_join(d_year1, d_year)

```

Ideally, we would like to have a dataframe of students against calendar years filled with the corresponding UCM year (e.g. if the year 2017 was the first year of student 45, we would like to see the cell corresponding to student 45 and year 2017 marked with a "1").

```{r}
var_years <- as.character(2007:2017)

d_time <- d_time %>% 
  mutate_at(
    vars(var_years),
    funs(. - Subs_year)) %>%
  mutate_at(
    vars(var_years),
    funs(case_when(. < 0 ~ 9999999999, #HORRIBLE FIX
                   T     ~ .)))

d_time[d_time == 9999999999] <- NA

```

Now, lets get the data as we want it for our analysis. For our analysis we would like to know what course a student took, when, whether they passed or failed, what grade they got, what the concentration of the student is, and what the concentration of the course is (we will convert grades to numeric here). Then, we would like to know on what year of their studies the student took the course.For this we will create a years dictionary and join it with our student data:

```{r}
d_students <- d_grade %>%
  select(ID, Code, Year, Period, Grade, Attempt,`Booking Status Description`, `Course concentration`) %>%
  arrange(ID, Year, Period)%>%
  left_join(d_student_concentration, by="ID") %>%
  mutate(Grade = as.numeric( sub(",",".", Grade))) %>%
  replace_na(list(Grade=-1))

# Years dictionary:
year_dic <- d_time %>%
  select(-FirstYear,-LastYear,-LengthUCM,-Subs_year)%>%
  gather(Cal_Year,UCM_Year,var_years)%>%
  drop_na(.) %>%
  mutate(Year=as.integer(Cal_Year))%>%
  select(-Cal_Year)

#adding the ucm year to transcripts:
d_students <- d_students %>%
  left_join(year_dic, by=c("ID","Year"))

#removing repeated values:
d_students <- d_students[!duplicated(d_students),]

```

###Removing master Program data and Cleaning Capstone Data 
We noticed that we had the data for people who stayed at this university for their masters. To filter these courses out we find out in which year people took their capstone courses.

For this we keep only the capstones. We expect some people to have repeated capstones:
```{r}
capstone_count <- d_students %>%
  filter(Code=="CAP3000") %>%
  group_by(ID)%>%
  summarise(Count=n())

capstone_count
```
However, what is surptising is that some people have two different passed capstones:

```{r}
passed_capstone_count <- d_students %>%
  filter(Code=="CAP3000", `Booking Status Description`=="Completed with Success") %>%
  group_by(ID) %>%
  summarise(Count=n(), Max = max(Grade), Min = min(Grade), Attempts= max(Attempt))

```

We can check the grades for people who had repeated passed capstones (lets just bring them to the top of the list):
```{r}
passed_capstone_count %>%
  arrange(desc(Count), desc(Min), Attempts)
```
There are 1712 people who did capstone. We see that most students who have two passed Capstones, have in reality only 1, since the other capstone had a failing grade and the passing grade was on the second attempt (count starts at 0) was indeed failed. However there are two students who indeed have two different passed Capstones: one is student 282995 who has two different passing grades(because of a change in grading system at the collegue during the year 2008-2009), the other is student 544450 who has the same grade passed at two different moment in time.

We can check if there are any students with passing capstone who do not have a grade of at least 5.5. We do this by looking at the lowest Max values:
```{r}
passed_capstone_count %>%
  arrange(Max)
```
We see the lowest grade for a passing capstone is 5.6, so this is fine. 


Now lets just keep the highest value for each student and correct for student 282995:
```{r}
passed_capstone_grades <- passed_capstone_count %>%
  mutate(`Booking Status Description`= "Completed with Success", Code="CAP3000", Grade= case_when(ID== 282995~7.7,
                                                                                  T~Max)) %>%
  select( ID, Code, Grade,`Booking Status Description`)
passed_capstone_grades
```

####Capstone Year
Now we can figure out the Capstone Year.

First we get the years for which there is a corresponding passing capstone grade, and check for repetition:
```{r}

capstone_finish_year <- inner_join(passed_capstone_grades, d_students) 

head(capstone_finish_year)

count_before <- passed_capstone_grades %>%
  group_by(ID) %>%
  summarise(counts_of_id= n())

count_after <- capstone_finish_year %>%
  group_by(ID) %>%
  summarise(counts_of_id= n())%>%
  filter(counts_of_id > 1)  #these students have repeated capstones.

count_after
  
```
From count_after we see that student 544450 has two passed capstones at different moments in time, we already knew this and we must ask Richard why this is the case. However, since both capstones where passed in 2010, this creates no problem for our current purposes. However, let's remove the later version.
We will also rename `Year` to `Capstone Year` and keep only the columns `Capstone Year` and `ID`
```{r}
to_remove <- capstone_finish_year%>%
  filter(ID==544450)
to_remove <- to_remove[duplicated(to_remove$ID),]

capstone_finish_year <- capstone_finish_year%>%
  anti_join(to_remove) %>%
  rename(`Capstone Year`= Year)%>%
  select(ID,`Capstone Year`)
  
capstone_finish_year
```


Lets create a dataframe where we include the capstone year. Then, if a course is given later than the capstone year, we want to remove it. Therefore, lets substitute na values with the year 9999 (or will ucm be open in the year 9999?).
```{r}
d_transcripts <- d_students %>%
  group_by(ID) %>%
  left_join(capstone_finish_year) %>%
  ungroup() %>%
  replace_na(list(`Capstone Year`=9999)) %>%
  mutate(`After Graduation`=`Capstone Year`-`Year`)

d_transcripts
```
Now we will remove all courses with negative `After Graduation`:
```{r}
master_courses <- d_transcripts%>%
  filter(`After Graduation`<0)

d_transcripts <- d_transcripts %>%
  anti_join(master_courses)

head(d_transcripts)

```

One last thing. The variable `Booking Status Description` shows whether a student passed or failed the course. However, some mistakes in the way the data was handled meant that the course status of some students was never confirmed. We need to ASK RICHARD, but for the moment, we will just look at the grades of those courses which were not confirmed to change into pass and fail.

```{r}
booked <- filter(d_transcripts, d_transcripts$`Booking Status Description`=="Booked")%>%
  mutate(`Booking Status Description`= case_when(Grade<5.5~"Completed Unsuccessfully",
                                                 Grade>5.5~"Completed with Success"))


clean_transcripts <- d_transcripts %>% 
  left_join(booked, by= c("ID", "Code", "Year", "Period", "Grade", "Attempt", "Course concentration", "student_Concentration", "Capstone Year", "After Graduation"), suffix=c("-old", "-new"))%>%
  select(-`After Graduation`)%>%
  mutate(Pass= case_when(
    (`Booking Status Description-new`=="Completed with Success")~"Pass",
    (`Booking Status Description-new`=="Completed Unsuccessfully")~"Fail",
    (`Booking Status Description-old`=="Completed with Success")~"Pass",
    (`Booking Status Description-old`=="Completed Unsuccessfully")~"Fail",
    T~"error in clean_transcripts"
  )) %>%
  select(-`Booking Status Description-new`,-`Booking Status Description-old`,-"UCM_Year-new")
```
####Ordering in Time
We would like to have a column `Time` that codes for both year and period (e.g. Year_1 Period_2 should be 1.2), as well as a column `Periods` with the year and period as numbers (e.g. Year_2 Period_1 should be period 7).

CHECK: we still have students who's first record is of their last year. This appears as UCM_Year=1.

```{r}

a_clean_transcripts <- clean_transcripts%>%
  separate(Period, 
           c("T1","T2","T3","T4","T5","T6"), 
           sep="," 
           ) %>%
  gather( key = "Time", value = "Period", T1,T2,T3,T4,T5,T6) %>%
  drop_na(Period) %>%
  select(-Time) %>%
  mutate(Periods = (`UCM_Year-old` - 1) * 6 + 
           as.numeric(Period)
         )
  
a_clean_transcripts$Time= paste(a_clean_transcripts$`UCM_Year-old`,
                                a_clean_transcripts$Period, 
                                sep="."
                                )
#FINAL DATA:
d_transcript <-a_clean_transcripts%>%
  select(-`UCM_Year-old`,-Period)
```
NOTES: The data is now arranged so as to respect the order in time for each individual student. However, the comparison is still tricky as people who finished in 2008 will have CAP recorded as taken on their first year since this is all the data we have. 
COMMENT SOFIA: save a_clean_transcript as d_transcript

# Save Data

```{r}
save(lists, d_course, d_AoD, d_assessment, d_transcript,
     file = "data_pillar_1.RDATA")
save(lists, d_course, d_AoD, d_assessment, d_transcript,
     d_overview_stem, d_description_stem,
     file = "data_pillar_2.RDATA")
```

[^1]: We do not include all assessments and all AoDs on the plots in order to keep them readable.

[^2]: We are currently cleaning the dataset containing the transcripts of all the students of the college (alumni and current students) in order to integrate it to the analysis.