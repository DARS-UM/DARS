---
title: "Pillar 1 - Sequential Pattern Mining"
author: "DARS"
date: "`r Sys.Date()`"
output: 
  github_document:
    toc: TRUE
---

```{r library, message = F}
#detach(package:tm, unload=TRUE) #there is overlap with tm package in inspect()

library(tidyverse)
library(arules)
library(arulesSequences)
```

# Setup
load previous data and create function to find courses
```{r}
load("data_pillar_1.RDATA")

find_course <- function(code){ #can be modified to accept other data that is not d_transcript
  c = code
  x <- d_transcript %>%
    filter(`Course Code`== c)
  
  return(x$`Course Title`[1])
}

```

#Data Exploration of Transcripts
```{r}
exploration <- d_transcript %>%
  mutate(Grade = case_when(Grade == "NG"~ "-1", #"0,0", #maybe we could just remove these from the analysis and treat them separately?
                           T~Grade),
         Grade = str_replace(string = Grade, pattern = ",",replace = "."),
         Grade = as.numeric(Grade))%>%
  filter(!is.na(Grade)) %>%
  filter(Grade != -1) #remove NG

summary(exploration)

student_statistics <- exploration %>%
  group_by(`Student ID Number`) %>%
  summarise(n = n(),
            Min = min(Grade), 
            Max = max(Grade), 
            Mean = mean(Grade), 
            Median = median(Grade), 
            SD = sd(Grade), 
            `Proportion Failed` = mean(Grade < 5.5))

course_statistics <- exploration %>%
  group_by(`Course Code`) %>%
  summarise(n = n(),
            Min = min(Grade), 
            Max = max(Grade), 
            Mean = mean(Grade), 
            Median = median(Grade), 
            SD = sd(Grade), 
            `Proportion Failed` = mean(Grade < 5.5)) %>%
  inner_join(d_course, by= c("Course Code" = "Code")) #to get only UCM courses for which we have statistics

#We have NA in grades. Something weird is happening. 
summary(str_detect(d_transcript$Grade, pattern="NA")) #shows NA's = 312 FALSE= 89069 WHY ARE THERE NAs?

has_na <- d_transcript %>%
  mutate(What = str_detect(Grade, pattern="NA")) %>%
  filter(is.na(What))
```
We have found some NA values for the grades! Students:
0177849- COR1003 & EMTH0001  +++++++++++++++ Master thesis should not be showing up! +++++++++++++
0177857
0222100
0270148
0313173
0317101
0317349

#Getting graphics
```{r}

```


#Getting dates
For a first exploration of arules, we conceptualise our framework like this:
transaction = student
item = course

##Data preparation
First we transform our data into transaction data. For this, we first create a vector of mandatory courses that we exclude from transcripts. 

```{r}
d_transactions <- d_course %>%
  select(Type, Code, Letters) %>%
  filter(Type == "Elective",
         ! Letters %in% c("SKI", "PRO"),
         ! Letters %in% c("SAS", "SAH", "SAC")) %>%
  select(Code) %>%
  left_join(d_transcript, by = c("Code" = "Course Code")) %>%
  select(`Student ID Number`, Code) %>%
  group_by(`Student ID Number`) %>%
  summarize(list_course = list(Code)) %>%
  group_by()

transactions <- as(d_transactions$list_course, "transactions")
```

We apply Apriori algorithm:
```{r}
results <- apriori(
  data = transactions, 
  parameter = list(
    supp = 0.02,
    smax = 1, # max support
    conf = 0.4,
    minlen = 2,
    maxlen = 2
    ),
  appearance = NULL,
  control = NULL
  ) %>%
  inspect

colnames(results)[2] <- "association"

results %>%
  arrange(desc(confidence))
```
Now we include data for pass and fail:
```{r}
d_transaction_passed <- d_course %>%
  select(Type, Code, Letters) %>%
  filter(Type == "Elective",
         ! Letters %in% c("SKI", "PRO"),
         ! Letters %in% c("SAS", "SAH", "SAC")) %>%
  select(Code) %>%
  left_join(d_transcript, by = c("Code" = "Course Code")) %>%
  mutate(Outcome = case_when(Grade=="NG"~"Fail",
                             Grade > 5.5 ~"Pass",
                             T~"Fail")) %>%
  mutate(Item= paste(Code, Outcome, sep = "_")) %>%
  select(`Student ID Number`, Item) %>%
  group_by(`Student ID Number`) %>%
  summarize(list_course = list(Item)) %>%
  group_by()

transactions_passed <- as(d_transaction_passed$list_course, "transactions")

```
We apply Apriori algorithm:
```{r}
results_passed <- apriori(
  data = transactions_passed, 
  parameter = list(
    supp = 0,
    smax = 1, # max support
    conf = 0.4,
    minlen = 2,
    maxlen = 2
    ),
  appearance = NULL,
  control = NULL
  ) %>%
  inspect

colnames(results_passed)[2] <- "association"

results_passed %>%
  separate(lhs, into = c("LHS", "LHS_pass"), sep= "_", remove = F) %>%
  separate(rhs, into = c("RHS", "RHS_pass"), sep= "_", remove = F) %>%
  filter(RHS_pass == "Fail}") %>%
  arrange(desc(count))
```
#Mining-sequences
Let I = {I1, I2,..., Ip} be the set of all items. An itemset is a nonempty set of items. A sequence is an ordered list of events. A sequence s is denoted <e1e2e3 ···el>, where event e1 occurs before e2, which occurs before e3, and so on. Event ej is also called an element of s. In the case of customer purchase data, an event refers to a shopping trip in which a customer bought items at a certain store. The event is thus an itemset, that is, an unordered list of items that the customer purchased during the trip. The itemset (or event) is denoted (x1x2 ···xq), where xk is an item. For brevity, the brackets are omitted if an element has only one item, that is, element (x) is written as x. 

SequenceID = `Student ID Number`
Event ID   =  UCM_YEAR_Period OR Year_period. 
Items      =  Course
```{r}
d_sequence_transactions <- d_course %>%
  select(Type, Code, Letters) %>%
  filter(Type == "Elective",
         ! Letters %in% c("SKI", "PRO"),
         ! Letters %in% c("SAS", "SAH", "SAC")) %>%
  select(Code) %>%
  left_join(d_transcript, by = c("Code" = "Course Code")) %>%
  filter(!str_detect(Period, " to ")) %>% #filter courses that spann more than one period
  mutate( Time = paste(Year_numerical, Period, sep = ""),
          Time = as.double(Time)) %>%
  select(`Student ID Number`, Code, Time) %>%
  arrange(`Student ID Number`, Time) %>% #Note that integer identifiers must be positive and that transactions must be ordered by sequenceID and eventID.
  group_by(`Student ID Number`, Time) %>%
  summarize(list_course = list(Code)) %>% #if we run the code until here maybe its possible to use sequence_transactions <- as(sequence_transaction$list_course, "transactions")
  mutate(TransactionID = paste(`Student ID Number`, Time, sep = "_"))

list_course <- d_sequence_transactions$list_course
names(list_course) <- d_sequence_transactions$TransactionID

my_transactions <- as(list_course, "transactions")
transactionInfo(my_transactions)$sequenceID <- d_sequence_transactions$`Student ID Number`
transactionInfo(my_transactions)$eventID <- d_sequence_transactions$Time
transactionInfo(my_transactions)$transactionID <- NULL

```

now we find frequent sequential patterns. 
The parameter values are: 
support:  a numeric value specifying the minimum support of a sequence (default 0.1, range [0,1]).

maxsize:  an integer value specifying the maximum number of items of an element of a sequence (default 10, range > 0).
maxlen:   an integer value specifying the maximum number of elements of a sequence (default 10, range > 0).
mingap:   an integer value specifying the minimum time difference between consecutive elements of a sequence (default none, range >= 1).
maxgap:   an integer value specifying the maximum time difference between consecutive elements of a sequence (default none, range >= 0).
maxwin:   an integer value specifying the maximum time difference between any two elements of a sequence (default none, range >= 0).
```{r}
summary(my_transactions)

frequent_trajectories <- cspade(my_transactions, parameter = list(support = 0.01), control   = list(verbose = TRUE))
#Looking into this: 
summary(frequent_trajectories)
as(frequent_trajectories, "data.frame")

inspect(head(frequent_trajectories))
		
```

```{r}
rules <- ruleInduction(frequent_trajectories, confidence = 0.2, #we need to play with the parameters.
                    control    = list(verbose = TRUE))
as(rules, "data.frame") %>%
  arrange(desc(lift))
```
#Sequence mining with pass fail.
First we add pass fai information to our data set and transform it to transactions class:
```{r}
#sequences
fail_threshold <- 6.5

d_pass_sequence_transactions <- d_course %>%
  select(Type, Code, Letters) %>%
  filter(Type == "Elective",
         ! Letters %in% c("SKI", "PRO"),
         ! Letters %in% c("SAS", "SAH", "SAC")) %>%
  select(Code) %>%
  left_join(d_transcript, by = c("Code" = "Course Code")) %>%
  mutate(Outcome = 
           case_when( Grade=="NG"~"Fail", #if we don't do this NG satisfies the condition for pass v
                      Grade > 5.5 ~"Pass",
                              T~"Fail"),
         Low_grade =
           case_when(Grade=="NG"~"low score", #if we don't do this NG satisfies the condition for pass v
                      Grade > fail_threshold ~"high score",
                              T~"low score")
         ) %>%
  mutate(Item = paste(Code, Low_grade, sep = "_") ) %>% #Change for Outcome/Low_grade
  filter(!str_detect(Period, " to ")) %>% #filter courses that spann more than one period
  mutate( Time = paste(Year_numerical, Period, sep = ""),
          Time = as.double(Time)) %>%
  select(`Student ID Number`, Item, Time) %>%
  arrange(`Student ID Number`, Time) %>% #Note that integer identifiers must be positive and that transactions must be ordered by sequenceID and eventID.
  group_by(`Student ID Number`, Time) %>%
  summarize(list_course = list(Item)) %>% #if we run the code until here maybe its possible to use sequence_transactions <- as(sequence_transaction$list_course, "transactions")
  mutate(TransactionID = paste(`Student ID Number`, Time, sep = "_"))

pass_list_course <- d_pass_sequence_transactions$list_course
names(pass_list_course) <- d_pass_sequence_transactions$TransactionID

pass_transactions <- as(pass_list_course, "transactions")
transactionInfo(pass_transactions)$sequenceID <- d_pass_sequence_transactions$`Student ID Number`
transactionInfo(pass_transactions)$eventID <- d_pass_sequence_transactions$Time
transactionInfo(pass_transactions)$transactionID <- NULL
```
Checking the results:
```{r}
as(pass_transactions, "data.frame")
frequent_pass_trajectories <- cspade(pass_transactions, parameter = list(support = 0.01), control   = list(verbose = TRUE))
summary(frequent_pass_trajectories)

pass_rules <- ruleInduction(frequent_pass_trajectories, confidence = 0.1, #we need to play with the parameters.
                    control    = list(verbose = TRUE))
pass_rules_df <- as(pass_rules, "data.frame") %>%
  arrange(desc(lift))
```
Checking who failed
```{r}
view_rules <- pass_rules_df %>%
  separate(rule, into=c("LHS", "RHS"), sep = "=>", remove = T) %>% #remove = F to keep columns
  filter(str_detect(RHS, "low score")) %>% #change so that it changes automatically
  arrange(desc(confidence), desc(lift))


write_csv(view_rules, "Data_Evgueni.csv")
```


#Unifying transaction data
```{r}
fail_threshold <- 6.5

category <-"Low_grade" #Outcome or Low_grade

d_pass_sequence_transactions <- d_course %>%
  select(Type, Code, Letters) %>%
  filter(Type == "Elective",
         ! Letters %in% c("SKI", "PRO"),
         ! Letters %in% c("SAS", "SAH", "SAC")) %>%
  select(Code) %>%
  left_join(d_transcript, by = c("Code" = "Course Code")) %>%
  mutate(Outcome = 
           case_when( Grade=="NG"~"Fail", #if we don't do this NG satisfies the condition for pass v
                      Grade > 5.5 ~"Pass",
                              T~"Fail"),
         Low_grade =
           case_when(Grade=="NG"~"low score", #if we don't do this NG satisfies the condition for pass v
                      Grade > fail_threshold ~"high score",
                              T~"low score")
         ) %>%
  mutate(Item = paste(Code, Low_grade, sep = "_") ) %>% #Change for Outcome/Low_grade
  filter(!str_detect(Period, " to ")) %>% #filter courses that spann more than one period
  mutate( Time = paste(Year_numerical, Period, sep = ""),
          Time = as.double(Time)) %>%
  select(`Student ID Number`, Item, Time) %>%
  arrange(`Student ID Number`, Time) %>% #Note that integer identifiers must be positive and that transactions must be ordered by sequenceID and eventID.
  group_by(`Student ID Number`, Time) %>%
  summarize(list_course = list(Item)) %>% #if we run the code until here maybe its possible to use sequence_transactions <- as(sequence_transaction$list_course, "transactions")
  mutate(TransactionID = paste(`Student ID Number`, Time, sep = "_"))
```

#Visualisation
It might be a nice idea to visualise using Sankey diagrams, although I don't know if there will be too many courses for it to be meaningful. We might need to sample. See https://analyzecore.com/2014/10/31/sequence-carts-analysis-sankey/ 






